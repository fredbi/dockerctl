// Code generated by go-swagger; DO NOT EDIT.

package cli

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/swarm"

	"github.com/spf13/cobra"

	"github.com/go-openapi/swag"
)

// makeOperationSwarmSwarmJoinCmd returns a command to handle operation swarmJoin
func makeOperationSwarmSwarmJoinCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "SwarmJoin",
		Short: ``,
		RunE:  runOperationSwarmSwarmJoin,
	}

	if err := registerOperationSwarmSwarmJoinParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationSwarmSwarmJoin uses cmd flags to call endpoint api
func runOperationSwarmSwarmJoin(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := swarm.NewSwarmJoinParams()
	if err, _ = retrieveOperationSwarmSwarmJoinBodyFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {
		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationSwarmSwarmJoinResult(appCli.Swarm.SwarmJoin(params))
	if err != nil {
		return err
	}

	if !debug {
		fmt.Println(msgStr)
	}

	return nil
}

// registerOperationSwarmSwarmJoinParamFlags registers all flags needed to fill params
func registerOperationSwarmSwarmJoinParamFlags(cmd *cobra.Command) error {
	if err := registerOperationSwarmSwarmJoinBodyParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationSwarmSwarmJoinBodyParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var flagBodyName string
	if cmdPrefix == "" {
		flagBodyName = "body"
	} else {
		flagBodyName = fmt.Sprintf("%v.body", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(flagBodyName, "", `Optional json string for [body]. `)

	// add flags for body
	if err := registerModelSwarmJoinBodyFlags(0, "swarmJoinBody", cmd); err != nil {
		return err
	}

	return nil
}

func retrieveOperationSwarmSwarmJoinBodyFlag(m *swarm.SwarmJoinParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("body") {
		// Read body string from cmd and unmarshal
		flagBodyValueStr, err := cmd.Flags().GetString("body")
		if err != nil {
			return err, false
		}

		flagBodyValue := swarm.SwarmJoinBody{}
		if err := json.Unmarshal([]byte(flagBodyValueStr), &flagBodyValue); err != nil {
			return fmt.Errorf("cannot unmarshal body string in SwarmJoinBody: %w", err), false
		}
		m.Body = flagBodyValue
	}
	flagBodyModel := m.Body
	if swag.IsZero(flagBodyModel) {
		flagBodyModel = swarm.SwarmJoinBody{}
	}
	err, added := retrieveModelSwarmJoinBodyFlags(0, &flagBodyModel, "swarmJoinBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.Body = flagBodyModel
	}

	if dryRun && debug {
		flagBodyValueDebugBytes, err := json.Marshal(m.Body)
		if err != nil {
			return err, false
		}
		logDebugf("Body dry-run payload: %v", string(flagBodyValueDebugBytes))
	}

	retAdded = retAdded || added

	return nil, retAdded
}

// parseOperationSwarmSwarmJoinResult parses request result and return the string content
func parseOperationSwarmSwarmJoinResult(resp0 *swarm.SwarmJoinOK, respErr error) (string, error) {
	if respErr != nil {

		// responses
		// Non schema case: warning swarmJoinOK is not supported
		var iResp1 any = respErr
		eresp1, ok := iResp1.(*swarm.SwarmJoinBadRequest)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp1) && !swag.IsZero(eresp1.Payload) {
				msgStr, err := json.Marshal(eresp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp2 any = respErr
		eresp2, ok := iResp2.(*swarm.SwarmJoinInternalServerError)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp2) && !swag.IsZero(eresp2.Payload) {
				msgStr, err := json.Marshal(eresp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp3 any = respErr
		eresp3, ok := iResp3.(*swarm.SwarmJoinServiceUnavailable)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp3) && !swag.IsZero(eresp3.Payload) {
				msgStr, err := json.Marshal(eresp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		return "", respErr
	}

	// success responses
	// warning: non schema response swarmJoinOK is not supported by go-swagger cli yet.
	return "", nil
}

// register flags to command
func registerModelSwarmJoinBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerSwarmJoinBodyPropAdvertiseAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyPropDataPathAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyPropJoinToken(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyPropListenAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyPropRemoteAddrs(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmJoinBodyPropAdvertiseAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagAdvertiseAddrDescription := `Externally reachable address advertised to other nodes. This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the port number from the listen address is used. If ` + "`" + `AdvertiseAddr` + "`" + ` is not specified, it will be automatically detected when possible.`

	var flagAdvertiseAddrName string
	if cmdPrefix == "" {
		flagAdvertiseAddrName = "AdvertiseAddr"
	} else {
		flagAdvertiseAddrName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	}

	var flagAdvertiseAddrDefault string

	_ = cmd.PersistentFlags().String(flagAdvertiseAddrName, flagAdvertiseAddrDefault, flagAdvertiseAddrDescription)

	return nil
}

func registerSwarmJoinBodyPropDataPathAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagDataPathAddrDescription := `Address or interface to use for data path traffic (format: ` + "`" + `<ip|interface>` + "`" + `), for example,  ` + "`" + `192.168.1.1` + "`" + `,
or an interface, like ` + "`" + `eth0` + "`" + `. If ` + "`" + `DataPathAddr` + "`" + ` is unspecified, the same address as ` + "`" + `AdvertiseAddr` + "`" + `
is used.

The ` + "`" + `DataPathAddr` + "`" + ` specifies the address that global scope network drivers will publish towards other
nodes in order to reach the containers running on this node. Using this parameter it is possible to
separate the container data traffic from the management traffic of the cluster.
`

	var flagDataPathAddrName string
	if cmdPrefix == "" {
		flagDataPathAddrName = "DataPathAddr"
	} else {
		flagDataPathAddrName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	}

	var flagDataPathAddrDefault string

	_ = cmd.PersistentFlags().String(flagDataPathAddrName, flagDataPathAddrDefault, flagDataPathAddrDescription)

	return nil
}

func registerSwarmJoinBodyPropJoinToken(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagJoinTokenDescription := `Secret token for joining this swarm.`

	var flagJoinTokenName string
	if cmdPrefix == "" {
		flagJoinTokenName = "JoinToken"
	} else {
		flagJoinTokenName = fmt.Sprintf("%v.JoinToken", cmdPrefix)
	}

	var flagJoinTokenDefault string

	_ = cmd.PersistentFlags().String(flagJoinTokenName, flagJoinTokenDefault, flagJoinTokenDescription)

	return nil
}

func registerSwarmJoinBodyPropListenAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagListenAddrDescription := `Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).`

	var flagListenAddrName string
	if cmdPrefix == "" {
		flagListenAddrName = "ListenAddr"
	} else {
		flagListenAddrName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	}

	var flagListenAddrDefault string

	_ = cmd.PersistentFlags().String(flagListenAddrName, flagListenAddrDefault, flagListenAddrDescription)

	return nil
}

func registerSwarmJoinBodyPropRemoteAddrs(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: RemoteAddrs []string array type is not supported by go-swagger cli yet

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelSwarmJoinBodyFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, AdvertiseAddrAdded := retrieveSwarmJoinBodyPropAdvertiseAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AdvertiseAddrAdded

	err, DataPathAddrAdded := retrieveSwarmJoinBodyPropDataPathAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DataPathAddrAdded

	err, JoinTokenAdded := retrieveSwarmJoinBodyPropJoinTokenFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || JoinTokenAdded

	err, ListenAddrAdded := retrieveSwarmJoinBodyPropListenAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || ListenAddrAdded

	err, RemoteAddrsAdded := retrieveSwarmJoinBodyPropRemoteAddrsFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || RemoteAddrsAdded

	return nil, retAdded
}

func retrieveSwarmJoinBodyPropAdvertiseAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagAdvertiseAddrName := fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	if cmd.Flags().Changed(flagAdvertiseAddrName) {

		var flagAdvertiseAddrName string
		if cmdPrefix == "" {
			flagAdvertiseAddrName = "AdvertiseAddr"
		} else {
			flagAdvertiseAddrName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
		}

		flagAdvertiseAddrValue, err := cmd.Flags().GetString(flagAdvertiseAddrName)
		if err != nil {
			return err, false
		}
		m.AdvertiseAddr = flagAdvertiseAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyPropDataPathAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagDataPathAddrName := fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	if cmd.Flags().Changed(flagDataPathAddrName) {

		var flagDataPathAddrName string
		if cmdPrefix == "" {
			flagDataPathAddrName = "DataPathAddr"
		} else {
			flagDataPathAddrName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
		}

		flagDataPathAddrValue, err := cmd.Flags().GetString(flagDataPathAddrName)
		if err != nil {
			return err, false
		}
		m.DataPathAddr = flagDataPathAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyPropJoinTokenFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagJoinTokenName := fmt.Sprintf("%v.JoinToken", cmdPrefix)
	if cmd.Flags().Changed(flagJoinTokenName) {

		var flagJoinTokenName string
		if cmdPrefix == "" {
			flagJoinTokenName = "JoinToken"
		} else {
			flagJoinTokenName = fmt.Sprintf("%v.JoinToken", cmdPrefix)
		}

		flagJoinTokenValue, err := cmd.Flags().GetString(flagJoinTokenName)
		if err != nil {
			return err, false
		}
		m.JoinToken = flagJoinTokenValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyPropListenAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagListenAddrName := fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	if cmd.Flags().Changed(flagListenAddrName) {

		var flagListenAddrName string
		if cmdPrefix == "" {
			flagListenAddrName = "ListenAddr"
		} else {
			flagListenAddrName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
		}

		flagListenAddrValue, err := cmd.Flags().GetString(flagListenAddrName)
		if err != nil {
			return err, false
		}
		m.ListenAddr = flagListenAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyPropRemoteAddrsFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagRemoteAddrsName := fmt.Sprintf("%v.RemoteAddrs", cmdPrefix)
	if cmd.Flags().Changed(flagRemoteAddrsName) {
		// warning: RemoteAddrs array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}
