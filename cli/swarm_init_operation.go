// Code generated by go-swagger; DO NOT EDIT.

package cli

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/swarm"
	"github.com/go-swagger/dockerctl/models"

	"github.com/spf13/cobra"

	"github.com/go-openapi/swag"
)

// makeOperationSwarmSwarmInitCmd returns a command to handle operation swarmInit
func makeOperationSwarmSwarmInitCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "SwarmInit",
		Short: ``,
		RunE:  runOperationSwarmSwarmInit,
	}

	if err := registerOperationSwarmSwarmInitParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationSwarmSwarmInit uses cmd flags to call endpoint api
func runOperationSwarmSwarmInit(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := swarm.NewSwarmInitParams()
	if err, _ = retrieveOperationSwarmSwarmInitBodyFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {
		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationSwarmSwarmInitResult(appCli.Swarm.SwarmInit(params))
	if err != nil {
		return err
	}

	if !debug {
		fmt.Println(msgStr)
	}

	return nil
}

// registerOperationSwarmSwarmInitParamFlags registers all flags needed to fill params
func registerOperationSwarmSwarmInitParamFlags(cmd *cobra.Command) error {
	if err := registerOperationSwarmSwarmInitBodyParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationSwarmSwarmInitBodyParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var flagBodyName string
	if cmdPrefix == "" {
		flagBodyName = "body"
	} else {
		flagBodyName = fmt.Sprintf("%v.body", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(flagBodyName, "", `Optional json string for [body]. `)

	// add flags for body
	if err := registerModelSwarmInitBodyFlags(0, "swarmInitBody", cmd); err != nil {
		return err
	}

	return nil
}

func retrieveOperationSwarmSwarmInitBodyFlag(m *swarm.SwarmInitParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("body") {
		// Read body string from cmd and unmarshal
		flagBodyValueStr, err := cmd.Flags().GetString("body")
		if err != nil {
			return err, false
		}

		flagBodyValue := swarm.SwarmInitBody{}
		if err := json.Unmarshal([]byte(flagBodyValueStr), &flagBodyValue); err != nil {
			return fmt.Errorf("cannot unmarshal body string in SwarmInitBody: %w", err), false
		}
		m.Body = flagBodyValue
	}
	flagBodyModel := m.Body
	if swag.IsZero(flagBodyModel) {
		flagBodyModel = swarm.SwarmInitBody{}
	}
	err, added := retrieveModelSwarmInitBodyFlags(0, &flagBodyModel, "swarmInitBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.Body = flagBodyModel
	}

	if dryRun && debug {
		flagBodyValueDebugBytes, err := json.Marshal(m.Body)
		if err != nil {
			return err, false
		}
		logDebugf("Body dry-run payload: %v", string(flagBodyValueDebugBytes))
	}

	retAdded = retAdded || added

	return nil, retAdded
}

// parseOperationSwarmSwarmInitResult parses request result and return the string content
func parseOperationSwarmSwarmInitResult(resp0 *swarm.SwarmInitOK, respErr error) (string, error) {
	if respErr != nil {

		// responses
		var iResp0 any = respErr
		eresp0, ok := iResp0.(*swarm.SwarmInitOK)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp0) && !swag.IsZero(eresp0.Payload) {
				msgStr, err := json.Marshal(eresp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp1 any = respErr
		eresp1, ok := iResp1.(*swarm.SwarmInitBadRequest)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp1) && !swag.IsZero(eresp1.Payload) {
				msgStr, err := json.Marshal(eresp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp2 any = respErr
		eresp2, ok := iResp2.(*swarm.SwarmInitInternalServerError)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp2) && !swag.IsZero(eresp2.Payload) {
				msgStr, err := json.Marshal(eresp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp3 any = respErr
		eresp3, ok := iResp3.(*swarm.SwarmInitServiceUnavailable)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp3) && !swag.IsZero(eresp3.Payload) {
				msgStr, err := json.Marshal(eresp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		return "", respErr
	}

	// success responses
	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr := fmt.Sprintf("%v", resp0.Payload)
		return string(msgStr), nil
	}
	return "", nil
}

// register flags to command
func registerModelSwarmInitBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerSwarmInitBodyPropAdvertiseAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropDataPathAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropDataPathPort(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropDefaultAddrPool(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropForceNewCluster(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropListenAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropSpec(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyPropSubnetSize(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmInitBodyPropAdvertiseAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagAdvertiseAddrDescription := `Externally reachable address advertised to other nodes. This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the port number from the listen address is used. If ` + "`" + `AdvertiseAddr` + "`" + ` is not specified, it will be automatically detected when possible.`

	var flagAdvertiseAddrName string
	if cmdPrefix == "" {
		flagAdvertiseAddrName = "AdvertiseAddr"
	} else {
		flagAdvertiseAddrName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	}

	var flagAdvertiseAddrDefault string

	_ = cmd.PersistentFlags().String(flagAdvertiseAddrName, flagAdvertiseAddrDefault, flagAdvertiseAddrDescription)

	return nil
}

func registerSwarmInitBodyPropDataPathAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagDataPathAddrDescription := `Address or interface to use for data path traffic (format: ` + "`" + `<ip|interface>` + "`" + `), for example,  ` + "`" + `192.168.1.1` + "`" + `,
or an interface, like ` + "`" + `eth0` + "`" + `. If ` + "`" + `DataPathAddr` + "`" + ` is unspecified, the same address as ` + "`" + `AdvertiseAddr` + "`" + `
is used.

The ` + "`" + `DataPathAddr` + "`" + ` specifies the address that global scope network drivers will publish towards other
nodes in order to reach the containers running on this node. Using this parameter it is possible to
separate the container data traffic from the management traffic of the cluster.
`

	var flagDataPathAddrName string
	if cmdPrefix == "" {
		flagDataPathAddrName = "DataPathAddr"
	} else {
		flagDataPathAddrName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	}

	var flagDataPathAddrDefault string

	_ = cmd.PersistentFlags().String(flagDataPathAddrName, flagDataPathAddrDefault, flagDataPathAddrDescription)

	return nil
}

func registerSwarmInitBodyPropDataPathPort(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: primitive DataPathPort uint32 is not supported by go-swagger cli yet

	return nil
}

func registerSwarmInitBodyPropDefaultAddrPool(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: DefaultAddrPool []string array type is not supported by go-swagger cli yet

	return nil
}

func registerSwarmInitBodyPropForceNewCluster(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagForceNewClusterDescription := `Force creation of a new swarm.`

	var flagForceNewClusterName string
	if cmdPrefix == "" {
		flagForceNewClusterName = "ForceNewCluster"
	} else {
		flagForceNewClusterName = fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
	}

	var flagForceNewClusterDefault bool

	_ = cmd.PersistentFlags().Bool(flagForceNewClusterName, flagForceNewClusterDefault, flagForceNewClusterDescription)

	return nil
}

func registerSwarmInitBodyPropListenAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagListenAddrDescription := `Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the default swarm listening port is used.`

	var flagListenAddrName string
	if cmdPrefix == "" {
		flagListenAddrName = "ListenAddr"
	} else {
		flagListenAddrName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	}

	var flagListenAddrDefault string

	_ = cmd.PersistentFlags().String(flagListenAddrName, flagListenAddrDefault, flagListenAddrDescription)

	return nil
}

func registerSwarmInitBodyPropSpec(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	var flagSpecName string
	if cmdPrefix == "" {
		flagSpecName = "Spec"
	} else {
		flagSpecName = fmt.Sprintf("%v.Spec", cmdPrefix)
	}

	if err := registerModelSwarmSpecFlags(depth+1, flagSpecName, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmInitBodyPropSubnetSize(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: primitive SubnetSize uint32 is not supported by go-swagger cli yet

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelSwarmInitBodyFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, AdvertiseAddrAdded := retrieveSwarmInitBodyPropAdvertiseAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AdvertiseAddrAdded

	err, DataPathAddrAdded := retrieveSwarmInitBodyPropDataPathAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DataPathAddrAdded

	err, DataPathPortAdded := retrieveSwarmInitBodyPropDataPathPortFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DataPathPortAdded

	err, DefaultAddrPoolAdded := retrieveSwarmInitBodyPropDefaultAddrPoolFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DefaultAddrPoolAdded

	err, ForceNewClusterAdded := retrieveSwarmInitBodyPropForceNewClusterFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || ForceNewClusterAdded

	err, ListenAddrAdded := retrieveSwarmInitBodyPropListenAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || ListenAddrAdded

	err, SpecAdded := retrieveSwarmInitBodyPropSpecFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SpecAdded

	err, SubnetSizeAdded := retrieveSwarmInitBodyPropSubnetSizeFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SubnetSizeAdded

	return nil, retAdded
}

func retrieveSwarmInitBodyPropAdvertiseAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagAdvertiseAddrName := fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	if cmd.Flags().Changed(flagAdvertiseAddrName) {

		var flagAdvertiseAddrName string
		if cmdPrefix == "" {
			flagAdvertiseAddrName = "AdvertiseAddr"
		} else {
			flagAdvertiseAddrName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
		}

		flagAdvertiseAddrValue, err := cmd.Flags().GetString(flagAdvertiseAddrName)
		if err != nil {
			return err, false
		}
		m.AdvertiseAddr = flagAdvertiseAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropDataPathAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagDataPathAddrName := fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	if cmd.Flags().Changed(flagDataPathAddrName) {

		var flagDataPathAddrName string
		if cmdPrefix == "" {
			flagDataPathAddrName = "DataPathAddr"
		} else {
			flagDataPathAddrName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
		}

		flagDataPathAddrValue, err := cmd.Flags().GetString(flagDataPathAddrName)
		if err != nil {
			return err, false
		}
		m.DataPathAddr = flagDataPathAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropDataPathPortFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagDataPathPortName := fmt.Sprintf("%v.DataPathPort", cmdPrefix)
	if cmd.Flags().Changed(flagDataPathPortName) {

		// warning: primitive DataPathPort uint32 is not supported by go-swagger cli yet

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropDefaultAddrPoolFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagDefaultAddrPoolName := fmt.Sprintf("%v.DefaultAddrPool", cmdPrefix)
	if cmd.Flags().Changed(flagDefaultAddrPoolName) {
		// warning: DefaultAddrPool array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropForceNewClusterFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagForceNewClusterName := fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
	if cmd.Flags().Changed(flagForceNewClusterName) {

		var flagForceNewClusterName string
		if cmdPrefix == "" {
			flagForceNewClusterName = "ForceNewCluster"
		} else {
			flagForceNewClusterName = fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
		}

		flagForceNewClusterValue, err := cmd.Flags().GetBool(flagForceNewClusterName)
		if err != nil {
			return err, false
		}
		m.ForceNewCluster = flagForceNewClusterValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropListenAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagListenAddrName := fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	if cmd.Flags().Changed(flagListenAddrName) {

		var flagListenAddrName string
		if cmdPrefix == "" {
			flagListenAddrName = "ListenAddr"
		} else {
			flagListenAddrName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
		}

		flagListenAddrValue, err := cmd.Flags().GetString(flagListenAddrName)
		if err != nil {
			return err, false
		}
		m.ListenAddr = flagListenAddrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropSpecFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagSpecName := fmt.Sprintf("%v.Spec", cmdPrefix)
	if cmd.Flags().Changed(flagSpecName) {
		// info: complex object Spec models.SwarmSpec is retrieved outside this Changed() block
	}
	flagSpecValue := m.Spec
	if swag.IsZero(flagSpecValue) {
		flagSpecValue = &models.SwarmSpec{}
	}

	err, SpecAdded := retrieveModelSwarmSpecFlags(depth+1, flagSpecValue, flagSpecName, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SpecAdded
	if SpecAdded {
		m.Spec = flagSpecValue
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyPropSubnetSizeFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagSubnetSizeName := fmt.Sprintf("%v.SubnetSize", cmdPrefix)
	if cmd.Flags().Changed(flagSubnetSizeName) {

		// warning: primitive SubnetSize uint32 is not supported by go-swagger cli yet

		retAdded = true
	}

	return nil, retAdded
}
