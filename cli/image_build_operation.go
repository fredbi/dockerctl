// Code generated by go-swagger; DO NOT EDIT.

package cli

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/image"

	"github.com/spf13/cobra"

	"github.com/go-openapi/swag"
)

// makeOperationImageImageBuildCmd returns a command to handle operation imageBuild
func makeOperationImageImageBuildCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use: "ImageBuild",
		Short: `Build an image from a tar archive with a ` + "`" + `Dockerfile` + "`" + ` in it.

The ` + "`" + `Dockerfile` + "`" + ` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the ` + "`" + `dockerfile` + "`" + ` parameter. [See the ` + "`" + `Dockerfile` + "`" + ` reference for more information](https://docs.docker.com/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the ` + "`" + `Dockerfile` + "`" + ` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.
`,
		RunE: runOperationImageImageBuild,
	}

	if err := registerOperationImageImageBuildParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationImageImageBuild uses cmd flags to call endpoint api
func runOperationImageImageBuild(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := image.NewImageBuildParams()
	if err, _ = retrieveOperationImageImageBuildContentTypeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildXRegistryConfigFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildBuildargsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildCachefromFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildCpuperiodFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildCpuquotaFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildCpusetcpusFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildCpusharesFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildDockerfileFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildExtrahostsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildForcermFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildInputStreamFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildLabelsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildMemoryFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildMemswapFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildNetworkmodeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildNocacheFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildOutputsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildPlatformFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildPullFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildQFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildRemoteFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildRmFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildShmsizeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildSquashFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildTFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationImageImageBuildTargetFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {
		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationImageImageBuildResult(appCli.Image.ImageBuild(params))
	if err != nil {
		return err
	}

	if !debug {
		fmt.Println(msgStr)
	}

	return nil
}

// registerOperationImageImageBuildParamFlags registers all flags needed to fill params
func registerOperationImageImageBuildParamFlags(cmd *cobra.Command) error {
	if err := registerOperationImageImageBuildContentTypeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildXRegistryConfigParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildBuildargsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCachefromParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpuperiodParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpuquotaParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpusetcpusParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpusharesParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildDockerfileParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildExtrahostsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildForcermParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildInputStreamParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildLabelsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildMemoryParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildMemswapParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildNetworkmodeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildNocacheParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildOutputsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildPlatformParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildPullParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildQParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildRemoteParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildRmParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildShmsizeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildSquashParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildTParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildTargetParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationImageImageBuildContentTypeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagContentTypeDescription := `Enum: ["application/x-tar"]. `

	var flagContentTypeName string
	if cmdPrefix == "" {
		flagContentTypeName = "Content-type"
	} else {
		flagContentTypeName = fmt.Sprintf("%v.Content-type", cmdPrefix)
	}

	var flagContentTypeDefault string = "application/x-tar"

	_ = cmd.PersistentFlags().String(flagContentTypeName, flagContentTypeDefault, flagContentTypeDescription)

	if err := cmd.RegisterFlagCompletionFunc(flagContentTypeName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["application/x-tar"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}

func registerOperationImageImageBuildXRegistryConfigParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagXRegistryConfigDescription := `This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.

The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:

` + "`" + `` + "`" + `` + "`" + `
{
  "docker.example.com": {
    "username": "janedoe",
    "password": "hunter2"
  },
  "https://index.docker.io/v1/": {
    "username": "mobydock",
    "password": "conta1n3rize14"
  }
}
` + "`" + `` + "`" + `` + "`" + `

Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a ` + "`" + `https://` + "`" + ` prefix and a ` + "`" + `/v1/` + "`" + ` suffix even though Docker will prefer to use the v2 registry API.
`

	var flagXRegistryConfigName string
	if cmdPrefix == "" {
		flagXRegistryConfigName = "X-Registry-Config"
	} else {
		flagXRegistryConfigName = fmt.Sprintf("%v.X-Registry-Config", cmdPrefix)
	}

	var flagXRegistryConfigDefault string

	_ = cmd.PersistentFlags().String(flagXRegistryConfigName, flagXRegistryConfigDefault, flagXRegistryConfigDescription)

	return nil
}

func registerOperationImageImageBuildBuildargsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagBuildargsDescription := `JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the ` + "`" + `Dockerfile` + "`" + ` RUN instruction, or for variable expansion in other ` + "`" + `Dockerfile` + "`" + ` instructions. This is not meant for passing secret values.

For example, the build arg ` + "`" + `FOO=bar` + "`" + ` would become ` + "`" + `{"FOO":"bar"}` + "`" + ` in JSON. This would result in the the query parameter ` + "`" + `buildargs={"FOO":"bar"}` + "`" + `. Note that ` + "`" + `{"FOO":"bar"}` + "`" + ` should be URI component encoded.

[Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)
`

	var flagBuildargsName string
	if cmdPrefix == "" {
		flagBuildargsName = "buildargs"
	} else {
		flagBuildargsName = fmt.Sprintf("%v.buildargs", cmdPrefix)
	}

	var flagBuildargsDefault string

	_ = cmd.PersistentFlags().String(flagBuildargsName, flagBuildargsDefault, flagBuildargsDescription)

	return nil
}

func registerOperationImageImageBuildCachefromParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagCachefromDescription := `JSON array of images used for build cache resolution.`

	var flagCachefromName string
	if cmdPrefix == "" {
		flagCachefromName = "cachefrom"
	} else {
		flagCachefromName = fmt.Sprintf("%v.cachefrom", cmdPrefix)
	}

	var flagCachefromDefault string

	_ = cmd.PersistentFlags().String(flagCachefromName, flagCachefromDefault, flagCachefromDescription)

	return nil
}

func registerOperationImageImageBuildCpuperiodParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagCpuperiodDescription := `The length of a CPU period in microseconds.`

	var flagCpuperiodName string
	if cmdPrefix == "" {
		flagCpuperiodName = "cpuperiod"
	} else {
		flagCpuperiodName = fmt.Sprintf("%v.cpuperiod", cmdPrefix)
	}

	var flagCpuperiodDefault int64

	_ = cmd.PersistentFlags().Int64(flagCpuperiodName, flagCpuperiodDefault, flagCpuperiodDescription)

	return nil
}

func registerOperationImageImageBuildCpuquotaParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagCpuquotaDescription := `Microseconds of CPU time that the container can get in a CPU period.`

	var flagCpuquotaName string
	if cmdPrefix == "" {
		flagCpuquotaName = "cpuquota"
	} else {
		flagCpuquotaName = fmt.Sprintf("%v.cpuquota", cmdPrefix)
	}

	var flagCpuquotaDefault int64

	_ = cmd.PersistentFlags().Int64(flagCpuquotaName, flagCpuquotaDefault, flagCpuquotaDescription)

	return nil
}

func registerOperationImageImageBuildCpusetcpusParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagCpusetcpusDescription := `CPUs in which to allow execution (e.g., ` + "`" + `0-3` + "`" + `, ` + "`" + `0,1` + "`" + `).`

	var flagCpusetcpusName string
	if cmdPrefix == "" {
		flagCpusetcpusName = "cpusetcpus"
	} else {
		flagCpusetcpusName = fmt.Sprintf("%v.cpusetcpus", cmdPrefix)
	}

	var flagCpusetcpusDefault string

	_ = cmd.PersistentFlags().String(flagCpusetcpusName, flagCpusetcpusDefault, flagCpusetcpusDescription)

	return nil
}

func registerOperationImageImageBuildCpusharesParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagCpusharesDescription := `CPU shares (relative weight).`

	var flagCpusharesName string
	if cmdPrefix == "" {
		flagCpusharesName = "cpushares"
	} else {
		flagCpusharesName = fmt.Sprintf("%v.cpushares", cmdPrefix)
	}

	var flagCpusharesDefault int64

	_ = cmd.PersistentFlags().Int64(flagCpusharesName, flagCpusharesDefault, flagCpusharesDescription)

	return nil
}

func registerOperationImageImageBuildDockerfileParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagDockerfileDescription := `Path within the build context to the ` + "`" + `Dockerfile` + "`" + `. This is ignored if ` + "`" + `remote` + "`" + ` is specified and points to an external ` + "`" + `Dockerfile` + "`" + `.`

	var flagDockerfileName string
	if cmdPrefix == "" {
		flagDockerfileName = "dockerfile"
	} else {
		flagDockerfileName = fmt.Sprintf("%v.dockerfile", cmdPrefix)
	}

	var flagDockerfileDefault string = "Dockerfile"

	_ = cmd.PersistentFlags().String(flagDockerfileName, flagDockerfileDefault, flagDockerfileDescription)

	return nil
}

func registerOperationImageImageBuildExtrahostsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagExtrahostsDescription := `Extra hosts to add to /etc/hosts`

	var flagExtrahostsName string
	if cmdPrefix == "" {
		flagExtrahostsName = "extrahosts"
	} else {
		flagExtrahostsName = fmt.Sprintf("%v.extrahosts", cmdPrefix)
	}

	var flagExtrahostsDefault string

	_ = cmd.PersistentFlags().String(flagExtrahostsName, flagExtrahostsDefault, flagExtrahostsDescription)

	return nil
}

func registerOperationImageImageBuildForcermParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagForcermDescription := `Always remove intermediate containers, even upon failure.`

	var flagForcermName string
	if cmdPrefix == "" {
		flagForcermName = "forcerm"
	} else {
		flagForcermName = fmt.Sprintf("%v.forcerm", cmdPrefix)
	}

	var flagForcermDefault bool

	_ = cmd.PersistentFlags().Bool(flagForcermName, flagForcermDefault, flagForcermDescription)

	return nil
}

func registerOperationImageImageBuildInputStreamParamFlags(cmdPrefix string, cmd *cobra.Command) error {
	// warning: go type io.ReadCloser is not supported by go-swagger cli yet.
	return nil
}

func registerOperationImageImageBuildLabelsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagLabelsDescription := `Arbitrary key/value labels to set on the image, as a JSON map of string pairs.`

	var flagLabelsName string
	if cmdPrefix == "" {
		flagLabelsName = "labels"
	} else {
		flagLabelsName = fmt.Sprintf("%v.labels", cmdPrefix)
	}

	var flagLabelsDefault string

	_ = cmd.PersistentFlags().String(flagLabelsName, flagLabelsDefault, flagLabelsDescription)

	return nil
}

func registerOperationImageImageBuildMemoryParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagMemoryDescription := `Set memory limit for build.`

	var flagMemoryName string
	if cmdPrefix == "" {
		flagMemoryName = "memory"
	} else {
		flagMemoryName = fmt.Sprintf("%v.memory", cmdPrefix)
	}

	var flagMemoryDefault int64

	_ = cmd.PersistentFlags().Int64(flagMemoryName, flagMemoryDefault, flagMemoryDescription)

	return nil
}

func registerOperationImageImageBuildMemswapParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagMemswapDescription := `Total memory (memory + swap). Set as ` + "`" + `-1` + "`" + ` to disable swap.`

	var flagMemswapName string
	if cmdPrefix == "" {
		flagMemswapName = "memswap"
	} else {
		flagMemswapName = fmt.Sprintf("%v.memswap", cmdPrefix)
	}

	var flagMemswapDefault int64

	_ = cmd.PersistentFlags().Int64(flagMemswapName, flagMemswapDefault, flagMemswapDescription)

	return nil
}

func registerOperationImageImageBuildNetworkmodeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagNetworkmodeDescription := `Sets the networking mode for the run commands during build. Supported
standard values are: ` + "`" + `bridge` + "`" + `, ` + "`" + `host` + "`" + `, ` + "`" + `none` + "`" + `, and ` + "`" + `container:<name|id>` + "`" + `.
Any other value is taken as a custom network's name or ID to which this
container should connect to.
`

	var flagNetworkmodeName string
	if cmdPrefix == "" {
		flagNetworkmodeName = "networkmode"
	} else {
		flagNetworkmodeName = fmt.Sprintf("%v.networkmode", cmdPrefix)
	}

	var flagNetworkmodeDefault string

	_ = cmd.PersistentFlags().String(flagNetworkmodeName, flagNetworkmodeDefault, flagNetworkmodeDescription)

	return nil
}

func registerOperationImageImageBuildNocacheParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagNocacheDescription := `Do not use the cache when building the image.`

	var flagNocacheName string
	if cmdPrefix == "" {
		flagNocacheName = "nocache"
	} else {
		flagNocacheName = fmt.Sprintf("%v.nocache", cmdPrefix)
	}

	var flagNocacheDefault bool

	_ = cmd.PersistentFlags().Bool(flagNocacheName, flagNocacheDefault, flagNocacheDescription)

	return nil
}

func registerOperationImageImageBuildOutputsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagOutputsDescription := `BuildKit output configuration`

	var flagOutputsName string
	if cmdPrefix == "" {
		flagOutputsName = "outputs"
	} else {
		flagOutputsName = fmt.Sprintf("%v.outputs", cmdPrefix)
	}

	var flagOutputsDefault string

	_ = cmd.PersistentFlags().String(flagOutputsName, flagOutputsDefault, flagOutputsDescription)

	return nil
}

func registerOperationImageImageBuildPlatformParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagPlatformDescription := `Platform in the format os[/arch[/variant]]`

	var flagPlatformName string
	if cmdPrefix == "" {
		flagPlatformName = "platform"
	} else {
		flagPlatformName = fmt.Sprintf("%v.platform", cmdPrefix)
	}

	var flagPlatformDefault string

	_ = cmd.PersistentFlags().String(flagPlatformName, flagPlatformDefault, flagPlatformDescription)

	return nil
}

func registerOperationImageImageBuildPullParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagPullDescription := `Attempt to pull the image even if an older image exists locally.`

	var flagPullName string
	if cmdPrefix == "" {
		flagPullName = "pull"
	} else {
		flagPullName = fmt.Sprintf("%v.pull", cmdPrefix)
	}

	var flagPullDefault string

	_ = cmd.PersistentFlags().String(flagPullName, flagPullDefault, flagPullDescription)

	return nil
}

func registerOperationImageImageBuildQParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagQDescription := `Suppress verbose build output.`

	var flagQName string
	if cmdPrefix == "" {
		flagQName = "q"
	} else {
		flagQName = fmt.Sprintf("%v.q", cmdPrefix)
	}

	var flagQDefault bool

	_ = cmd.PersistentFlags().Bool(flagQName, flagQDefault, flagQDescription)

	return nil
}

func registerOperationImageImageBuildRemoteParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagRemoteDescription := `A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the fileâ€™s contents are placed into a file called ` + "`" + `Dockerfile` + "`" + ` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the ` + "`" + `dockerfile` + "`" + ` parameter is also specified, there must be a file with the corresponding path inside the tarball.`

	var flagRemoteName string
	if cmdPrefix == "" {
		flagRemoteName = "remote"
	} else {
		flagRemoteName = fmt.Sprintf("%v.remote", cmdPrefix)
	}

	var flagRemoteDefault string

	_ = cmd.PersistentFlags().String(flagRemoteName, flagRemoteDefault, flagRemoteDescription)

	return nil
}

func registerOperationImageImageBuildRmParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagRmDescription := `Remove intermediate containers after a successful build.`

	var flagRmName string
	if cmdPrefix == "" {
		flagRmName = "rm"
	} else {
		flagRmName = fmt.Sprintf("%v.rm", cmdPrefix)
	}

	var flagRmDefault bool = true

	_ = cmd.PersistentFlags().Bool(flagRmName, flagRmDefault, flagRmDescription)

	return nil
}

func registerOperationImageImageBuildShmsizeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagShmsizeDescription := `Size of ` + "`" + `/dev/shm` + "`" + ` in bytes. The size must be greater than 0. If omitted the system uses 64MB.`

	var flagShmsizeName string
	if cmdPrefix == "" {
		flagShmsizeName = "shmsize"
	} else {
		flagShmsizeName = fmt.Sprintf("%v.shmsize", cmdPrefix)
	}

	var flagShmsizeDefault int64

	_ = cmd.PersistentFlags().Int64(flagShmsizeName, flagShmsizeDefault, flagShmsizeDescription)

	return nil
}

func registerOperationImageImageBuildSquashParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagSquashDescription := `Squash the resulting images layers into a single layer. *(Experimental release only.)*`

	var flagSquashName string
	if cmdPrefix == "" {
		flagSquashName = "squash"
	} else {
		flagSquashName = fmt.Sprintf("%v.squash", cmdPrefix)
	}

	var flagSquashDefault bool

	_ = cmd.PersistentFlags().Bool(flagSquashName, flagSquashDefault, flagSquashDescription)

	return nil
}

func registerOperationImageImageBuildTParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagTDescription := `A name and optional tag to apply to the image in the ` + "`" + `name:tag` + "`" + ` format. If you omit the tag the default ` + "`" + `latest` + "`" + ` value is assumed. You can provide several ` + "`" + `t` + "`" + ` parameters.`

	var flagTName string
	if cmdPrefix == "" {
		flagTName = "t"
	} else {
		flagTName = fmt.Sprintf("%v.t", cmdPrefix)
	}

	var flagTDefault string

	_ = cmd.PersistentFlags().String(flagTName, flagTDefault, flagTDescription)

	return nil
}

func registerOperationImageImageBuildTargetParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagTargetDescription := `Target build stage`

	var flagTargetName string
	if cmdPrefix == "" {
		flagTargetName = "target"
	} else {
		flagTargetName = fmt.Sprintf("%v.target", cmdPrefix)
	}

	var flagTargetDefault string

	_ = cmd.PersistentFlags().String(flagTargetName, flagTargetDefault, flagTargetDescription)

	return nil
}

func retrieveOperationImageImageBuildContentTypeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("Content-type") {

		var flagContentTypeName string
		if cmdPrefix == "" {
			flagContentTypeName = "Content-type"
		} else {
			flagContentTypeName = fmt.Sprintf("%v.Content-type", cmdPrefix)
		}

		flagContentTypeValue, err := cmd.Flags().GetString(flagContentTypeName)
		if err != nil {
			return err, false
		}
		m.ContentType = &flagContentTypeValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildXRegistryConfigFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("X-Registry-Config") {

		var flagXRegistryConfigName string
		if cmdPrefix == "" {
			flagXRegistryConfigName = "X-Registry-Config"
		} else {
			flagXRegistryConfigName = fmt.Sprintf("%v.X-Registry-Config", cmdPrefix)
		}

		flagXRegistryConfigValue, err := cmd.Flags().GetString(flagXRegistryConfigName)
		if err != nil {
			return err, false
		}
		m.XRegistryConfig = &flagXRegistryConfigValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildBuildargsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("buildargs") {

		var flagBuildargsName string
		if cmdPrefix == "" {
			flagBuildargsName = "buildargs"
		} else {
			flagBuildargsName = fmt.Sprintf("%v.buildargs", cmdPrefix)
		}

		flagBuildargsValue, err := cmd.Flags().GetString(flagBuildargsName)
		if err != nil {
			return err, false
		}
		m.Buildargs = &flagBuildargsValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildCachefromFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cachefrom") {

		var flagCachefromName string
		if cmdPrefix == "" {
			flagCachefromName = "cachefrom"
		} else {
			flagCachefromName = fmt.Sprintf("%v.cachefrom", cmdPrefix)
		}

		flagCachefromValue, err := cmd.Flags().GetString(flagCachefromName)
		if err != nil {
			return err, false
		}
		m.Cachefrom = &flagCachefromValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildCpuperiodFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpuperiod") {

		var flagCpuperiodName string
		if cmdPrefix == "" {
			flagCpuperiodName = "cpuperiod"
		} else {
			flagCpuperiodName = fmt.Sprintf("%v.cpuperiod", cmdPrefix)
		}

		flagCpuperiodValue, err := cmd.Flags().GetInt64(flagCpuperiodName)
		if err != nil {
			return err, false
		}
		m.Cpuperiod = &flagCpuperiodValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildCpuquotaFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpuquota") {

		var flagCpuquotaName string
		if cmdPrefix == "" {
			flagCpuquotaName = "cpuquota"
		} else {
			flagCpuquotaName = fmt.Sprintf("%v.cpuquota", cmdPrefix)
		}

		flagCpuquotaValue, err := cmd.Flags().GetInt64(flagCpuquotaName)
		if err != nil {
			return err, false
		}
		m.Cpuquota = &flagCpuquotaValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildCpusetcpusFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpusetcpus") {

		var flagCpusetcpusName string
		if cmdPrefix == "" {
			flagCpusetcpusName = "cpusetcpus"
		} else {
			flagCpusetcpusName = fmt.Sprintf("%v.cpusetcpus", cmdPrefix)
		}

		flagCpusetcpusValue, err := cmd.Flags().GetString(flagCpusetcpusName)
		if err != nil {
			return err, false
		}
		m.Cpusetcpus = &flagCpusetcpusValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildCpusharesFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpushares") {

		var flagCpusharesName string
		if cmdPrefix == "" {
			flagCpusharesName = "cpushares"
		} else {
			flagCpusharesName = fmt.Sprintf("%v.cpushares", cmdPrefix)
		}

		flagCpusharesValue, err := cmd.Flags().GetInt64(flagCpusharesName)
		if err != nil {
			return err, false
		}
		m.Cpushares = &flagCpusharesValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildDockerfileFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("dockerfile") {

		var flagDockerfileName string
		if cmdPrefix == "" {
			flagDockerfileName = "dockerfile"
		} else {
			flagDockerfileName = fmt.Sprintf("%v.dockerfile", cmdPrefix)
		}

		flagDockerfileValue, err := cmd.Flags().GetString(flagDockerfileName)
		if err != nil {
			return err, false
		}
		m.Dockerfile = &flagDockerfileValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildExtrahostsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("extrahosts") {

		var flagExtrahostsName string
		if cmdPrefix == "" {
			flagExtrahostsName = "extrahosts"
		} else {
			flagExtrahostsName = fmt.Sprintf("%v.extrahosts", cmdPrefix)
		}

		flagExtrahostsValue, err := cmd.Flags().GetString(flagExtrahostsName)
		if err != nil {
			return err, false
		}
		m.Extrahosts = &flagExtrahostsValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildForcermFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("forcerm") {

		var flagForcermName string
		if cmdPrefix == "" {
			flagForcermName = "forcerm"
		} else {
			flagForcermName = fmt.Sprintf("%v.forcerm", cmdPrefix)
		}

		flagForcermValue, err := cmd.Flags().GetBool(flagForcermName)
		if err != nil {
			return err, false
		}
		m.Forcerm = &flagForcermValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildInputStreamFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("inputStream") {
		// warning: io.ReadCloser is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildLabelsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("labels") {

		var flagLabelsName string
		if cmdPrefix == "" {
			flagLabelsName = "labels"
		} else {
			flagLabelsName = fmt.Sprintf("%v.labels", cmdPrefix)
		}

		flagLabelsValue, err := cmd.Flags().GetString(flagLabelsName)
		if err != nil {
			return err, false
		}
		m.Labels = &flagLabelsValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildMemoryFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("memory") {

		var flagMemoryName string
		if cmdPrefix == "" {
			flagMemoryName = "memory"
		} else {
			flagMemoryName = fmt.Sprintf("%v.memory", cmdPrefix)
		}

		flagMemoryValue, err := cmd.Flags().GetInt64(flagMemoryName)
		if err != nil {
			return err, false
		}
		m.Memory = &flagMemoryValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildMemswapFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("memswap") {

		var flagMemswapName string
		if cmdPrefix == "" {
			flagMemswapName = "memswap"
		} else {
			flagMemswapName = fmt.Sprintf("%v.memswap", cmdPrefix)
		}

		flagMemswapValue, err := cmd.Flags().GetInt64(flagMemswapName)
		if err != nil {
			return err, false
		}
		m.Memswap = &flagMemswapValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildNetworkmodeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("networkmode") {

		var flagNetworkmodeName string
		if cmdPrefix == "" {
			flagNetworkmodeName = "networkmode"
		} else {
			flagNetworkmodeName = fmt.Sprintf("%v.networkmode", cmdPrefix)
		}

		flagNetworkmodeValue, err := cmd.Flags().GetString(flagNetworkmodeName)
		if err != nil {
			return err, false
		}
		m.Networkmode = &flagNetworkmodeValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildNocacheFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("nocache") {

		var flagNocacheName string
		if cmdPrefix == "" {
			flagNocacheName = "nocache"
		} else {
			flagNocacheName = fmt.Sprintf("%v.nocache", cmdPrefix)
		}

		flagNocacheValue, err := cmd.Flags().GetBool(flagNocacheName)
		if err != nil {
			return err, false
		}
		m.Nocache = &flagNocacheValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildOutputsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("outputs") {

		var flagOutputsName string
		if cmdPrefix == "" {
			flagOutputsName = "outputs"
		} else {
			flagOutputsName = fmt.Sprintf("%v.outputs", cmdPrefix)
		}

		flagOutputsValue, err := cmd.Flags().GetString(flagOutputsName)
		if err != nil {
			return err, false
		}
		m.Outputs = &flagOutputsValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildPlatformFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("platform") {

		var flagPlatformName string
		if cmdPrefix == "" {
			flagPlatformName = "platform"
		} else {
			flagPlatformName = fmt.Sprintf("%v.platform", cmdPrefix)
		}

		flagPlatformValue, err := cmd.Flags().GetString(flagPlatformName)
		if err != nil {
			return err, false
		}
		m.Platform = &flagPlatformValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildPullFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("pull") {

		var flagPullName string
		if cmdPrefix == "" {
			flagPullName = "pull"
		} else {
			flagPullName = fmt.Sprintf("%v.pull", cmdPrefix)
		}

		flagPullValue, err := cmd.Flags().GetString(flagPullName)
		if err != nil {
			return err, false
		}
		m.Pull = &flagPullValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildQFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("q") {

		var flagQName string
		if cmdPrefix == "" {
			flagQName = "q"
		} else {
			flagQName = fmt.Sprintf("%v.q", cmdPrefix)
		}

		flagQValue, err := cmd.Flags().GetBool(flagQName)
		if err != nil {
			return err, false
		}
		m.Q = &flagQValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildRemoteFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("remote") {

		var flagRemoteName string
		if cmdPrefix == "" {
			flagRemoteName = "remote"
		} else {
			flagRemoteName = fmt.Sprintf("%v.remote", cmdPrefix)
		}

		flagRemoteValue, err := cmd.Flags().GetString(flagRemoteName)
		if err != nil {
			return err, false
		}
		m.Remote = &flagRemoteValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildRmFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("rm") {

		var flagRmName string
		if cmdPrefix == "" {
			flagRmName = "rm"
		} else {
			flagRmName = fmt.Sprintf("%v.rm", cmdPrefix)
		}

		flagRmValue, err := cmd.Flags().GetBool(flagRmName)
		if err != nil {
			return err, false
		}
		m.Rm = &flagRmValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildShmsizeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("shmsize") {

		var flagShmsizeName string
		if cmdPrefix == "" {
			flagShmsizeName = "shmsize"
		} else {
			flagShmsizeName = fmt.Sprintf("%v.shmsize", cmdPrefix)
		}

		flagShmsizeValue, err := cmd.Flags().GetInt64(flagShmsizeName)
		if err != nil {
			return err, false
		}
		m.Shmsize = &flagShmsizeValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildSquashFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("squash") {

		var flagSquashName string
		if cmdPrefix == "" {
			flagSquashName = "squash"
		} else {
			flagSquashName = fmt.Sprintf("%v.squash", cmdPrefix)
		}

		flagSquashValue, err := cmd.Flags().GetBool(flagSquashName)
		if err != nil {
			return err, false
		}
		m.Squash = &flagSquashValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildTFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("t") {

		var flagTName string
		if cmdPrefix == "" {
			flagTName = "t"
		} else {
			flagTName = fmt.Sprintf("%v.t", cmdPrefix)
		}

		flagTValue, err := cmd.Flags().GetString(flagTName)
		if err != nil {
			return err, false
		}
		m.T = &flagTValue

	}

	return nil, retAdded
}

func retrieveOperationImageImageBuildTargetFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("target") {

		var flagTargetName string
		if cmdPrefix == "" {
			flagTargetName = "target"
		} else {
			flagTargetName = fmt.Sprintf("%v.target", cmdPrefix)
		}

		flagTargetValue, err := cmd.Flags().GetString(flagTargetName)
		if err != nil {
			return err, false
		}
		m.Target = &flagTargetValue

	}

	return nil, retAdded
}

// parseOperationImageImageBuildResult parses request result and return the string content
func parseOperationImageImageBuildResult(resp0 *image.ImageBuildOK, respErr error) (string, error) {
	if respErr != nil {

		// responses
		// Non schema case: warning imageBuildOK is not supported
		var iResp1 any = respErr
		eresp1, ok := iResp1.(*image.ImageBuildBadRequest)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp1) && !swag.IsZero(eresp1.Payload) {
				msgStr, err := json.Marshal(eresp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp2 any = respErr
		eresp2, ok := iResp2.(*image.ImageBuildInternalServerError)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp2) && !swag.IsZero(eresp2.Payload) {
				msgStr, err := json.Marshal(eresp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		return "", respErr
	}

	// success responses
	// warning: non schema response imageBuildOK is not supported by go-swagger cli yet.
	return "", nil
}
