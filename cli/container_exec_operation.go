// Code generated by go-swagger; DO NOT EDIT.

package cli

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/exec"

	"github.com/spf13/cobra"

	"github.com/go-openapi/swag"
)

// makeOperationExecContainerExecCmd returns a command to handle operation containerExec
func makeOperationExecContainerExecCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "ContainerExec",
		Short: `Run a command inside a running container.`,
		RunE:  runOperationExecContainerExec,
	}

	if err := registerOperationExecContainerExecParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationExecContainerExec uses cmd flags to call endpoint api
func runOperationExecContainerExec(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := exec.NewContainerExecParams()
	if err, _ = retrieveOperationExecContainerExecExecConfigFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ = retrieveOperationExecContainerExecIDFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {
		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationExecContainerExecResult(appCli.Exec.ContainerExec(params))
	if err != nil {
		return err
	}

	if !debug {
		fmt.Println(msgStr)
	}

	return nil
}

// registerOperationExecContainerExecParamFlags registers all flags needed to fill params
func registerOperationExecContainerExecParamFlags(cmd *cobra.Command) error {
	if err := registerOperationExecContainerExecExecConfigParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationExecContainerExecIDParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationExecContainerExecExecConfigParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var flagExecConfigName string
	if cmdPrefix == "" {
		flagExecConfigName = "execConfig"
	} else {
		flagExecConfigName = fmt.Sprintf("%v.execConfig", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(flagExecConfigName, "", `Optional json string for [execConfig]. Exec configuration`)

	// add flags for body
	if err := registerModelContainerExecBodyFlags(0, "containerExecBody", cmd); err != nil {
		return err
	}

	return nil
}

func registerOperationExecContainerExecIDParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	flagIDDescription := `Required. ID or name of container`

	var flagIDName string
	if cmdPrefix == "" {
		flagIDName = "id"
	} else {
		flagIDName = fmt.Sprintf("%v.id", cmdPrefix)
	}

	var flagIDDefault string

	_ = cmd.PersistentFlags().String(flagIDName, flagIDDefault, flagIDDescription)

	return nil
}

func retrieveOperationExecContainerExecExecConfigFlag(m *exec.ContainerExecParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("execConfig") {
		// Read execConfig string from cmd and unmarshal
		flagExecConfigValueStr, err := cmd.Flags().GetString("execConfig")
		if err != nil {
			return err, false
		}

		flagExecConfigValue := exec.ContainerExecBody{}
		if err := json.Unmarshal([]byte(flagExecConfigValueStr), &flagExecConfigValue); err != nil {
			return fmt.Errorf("cannot unmarshal execConfig string in ContainerExecBody: %w", err), false
		}
		m.ExecConfig = flagExecConfigValue
	}
	flagExecConfigModel := m.ExecConfig
	if swag.IsZero(flagExecConfigModel) {
		flagExecConfigModel = exec.ContainerExecBody{}
	}
	err, added := retrieveModelContainerExecBodyFlags(0, &flagExecConfigModel, "containerExecBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.ExecConfig = flagExecConfigModel
	}

	if dryRun && debug {
		flagExecConfigValueDebugBytes, err := json.Marshal(m.ExecConfig)
		if err != nil {
			return err, false
		}
		logDebugf("ExecConfig dry-run payload: %v", string(flagExecConfigValueDebugBytes))
	}

	retAdded = retAdded || added

	return nil, retAdded
}

func retrieveOperationExecContainerExecIDFlag(m *exec.ContainerExecParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("id") {

		var flagIDName string
		if cmdPrefix == "" {
			flagIDName = "id"
		} else {
			flagIDName = fmt.Sprintf("%v.id", cmdPrefix)
		}

		flagIDValue, err := cmd.Flags().GetString(flagIDName)
		if err != nil {
			return err, false
		}
		m.ID = flagIDValue

	}

	return nil, retAdded
}

// parseOperationExecContainerExecResult parses request result and return the string content
func parseOperationExecContainerExecResult(resp0 *exec.ContainerExecCreated, respErr error) (string, error) {
	if respErr != nil {

		// responses
		var iResp0 any = respErr
		eresp0, ok := iResp0.(*exec.ContainerExecCreated)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp0) && !swag.IsZero(eresp0.Payload) {
				msgStr, err := json.Marshal(eresp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp1 any = respErr
		eresp1, ok := iResp1.(*exec.ContainerExecNotFound)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp1) && !swag.IsZero(eresp1.Payload) {
				msgStr, err := json.Marshal(eresp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp2 any = respErr
		eresp2, ok := iResp2.(*exec.ContainerExecConflict)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp2) && !swag.IsZero(eresp2.Payload) {
				msgStr, err := json.Marshal(eresp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		var iResp3 any = respErr
		eresp3, ok := iResp3.(*exec.ContainerExecInternalServerError)
		if ok {
			// the error response has a payload
			if !swag.IsZero(eresp3) && !swag.IsZero(eresp3.Payload) {
				msgStr, err := json.Marshal(eresp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}
		return "", respErr
	}

	// success responses
	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr, err := json.Marshal(resp0.Payload)
		if err != nil {
			return "", err
		}
		return string(msgStr), nil
	}
	return "", nil
}

// register flags to command
func registerModelContainerExecBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerContainerExecBodyPropAttachStderr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropAttachStdin(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropAttachStdout(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropCmd(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropDetachKeys(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropEnv(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropPrivileged(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropTty(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropUser(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPropWorkingDir(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerContainerExecBodyPropAttachStderr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagAttachStderrDescription := `Attach to ` + "`" + `stderr` + "`" + ` of the exec command.`

	var flagAttachStderrName string
	if cmdPrefix == "" {
		flagAttachStderrName = "AttachStderr"
	} else {
		flagAttachStderrName = fmt.Sprintf("%v.AttachStderr", cmdPrefix)
	}

	var flagAttachStderrDefault bool

	_ = cmd.PersistentFlags().Bool(flagAttachStderrName, flagAttachStderrDefault, flagAttachStderrDescription)

	return nil
}

func registerContainerExecBodyPropAttachStdin(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagAttachStdinDescription := `Attach to ` + "`" + `stdin` + "`" + ` of the exec command.`

	var flagAttachStdinName string
	if cmdPrefix == "" {
		flagAttachStdinName = "AttachStdin"
	} else {
		flagAttachStdinName = fmt.Sprintf("%v.AttachStdin", cmdPrefix)
	}

	var flagAttachStdinDefault bool

	_ = cmd.PersistentFlags().Bool(flagAttachStdinName, flagAttachStdinDefault, flagAttachStdinDescription)

	return nil
}

func registerContainerExecBodyPropAttachStdout(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagAttachStdoutDescription := `Attach to ` + "`" + `stdout` + "`" + ` of the exec command.`

	var flagAttachStdoutName string
	if cmdPrefix == "" {
		flagAttachStdoutName = "AttachStdout"
	} else {
		flagAttachStdoutName = fmt.Sprintf("%v.AttachStdout", cmdPrefix)
	}

	var flagAttachStdoutDefault bool

	_ = cmd.PersistentFlags().Bool(flagAttachStdoutName, flagAttachStdoutDefault, flagAttachStdoutDescription)

	return nil
}

func registerContainerExecBodyPropCmd(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: Cmd []string array type is not supported by go-swagger cli yet

	return nil
}

func registerContainerExecBodyPropDetachKeys(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagDetachKeysDescription := `Override the key sequence for detaching a container. Format is a single character ` + "`" + `[a-Z]` + "`" + ` or ` + "`" + `ctrl-<value>` + "`" + ` where ` + "`" + `<value>` + "`" + ` is one of: ` + "`" + `a-z` + "`" + `, ` + "`" + `@` + "`" + `, ` + "`" + `^` + "`" + `, ` + "`" + `[` + "`" + `, ` + "`" + `,` + "`" + ` or ` + "`" + `_` + "`" + `.`

	var flagDetachKeysName string
	if cmdPrefix == "" {
		flagDetachKeysName = "DetachKeys"
	} else {
		flagDetachKeysName = fmt.Sprintf("%v.DetachKeys", cmdPrefix)
	}

	var flagDetachKeysDefault string

	_ = cmd.PersistentFlags().String(flagDetachKeysName, flagDetachKeysDefault, flagDetachKeysDescription)

	return nil
}

func registerContainerExecBodyPropEnv(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: Env []string array type is not supported by go-swagger cli yet

	return nil
}

func registerContainerExecBodyPropPrivileged(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagPrivilegedDescription := `Runs the exec process with extended privileges.`

	var flagPrivilegedName string
	if cmdPrefix == "" {
		flagPrivilegedName = "Privileged"
	} else {
		flagPrivilegedName = fmt.Sprintf("%v.Privileged", cmdPrefix)
	}

	var flagPrivilegedDefault bool

	_ = cmd.PersistentFlags().Bool(flagPrivilegedName, flagPrivilegedDefault, flagPrivilegedDescription)

	return nil
}

func registerContainerExecBodyPropTty(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagTtyDescription := `Allocate a pseudo-TTY.`

	var flagTtyName string
	if cmdPrefix == "" {
		flagTtyName = "Tty"
	} else {
		flagTtyName = fmt.Sprintf("%v.Tty", cmdPrefix)
	}

	var flagTtyDefault bool

	_ = cmd.PersistentFlags().Bool(flagTtyName, flagTtyDefault, flagTtyDescription)

	return nil
}

func registerContainerExecBodyPropUser(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagUserDescription := `The user, and optionally, group to run the exec process inside the container. Format is one of: ` + "`" + `user` + "`" + `, ` + "`" + `user:group` + "`" + `, ` + "`" + `uid` + "`" + `, or ` + "`" + `uid:gid` + "`" + `.`

	var flagUserName string
	if cmdPrefix == "" {
		flagUserName = "User"
	} else {
		flagUserName = fmt.Sprintf("%v.User", cmdPrefix)
	}

	var flagUserDefault string

	_ = cmd.PersistentFlags().String(flagUserName, flagUserDefault, flagUserDescription)

	return nil
}

func registerContainerExecBodyPropWorkingDir(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	flagWorkingDirDescription := `The working directory for the exec process inside the container.`

	var flagWorkingDirName string
	if cmdPrefix == "" {
		flagWorkingDirName = "WorkingDir"
	} else {
		flagWorkingDirName = fmt.Sprintf("%v.WorkingDir", cmdPrefix)
	}

	var flagWorkingDirDefault string

	_ = cmd.PersistentFlags().String(flagWorkingDirName, flagWorkingDirDefault, flagWorkingDirDescription)

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelContainerExecBodyFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, AttachStderrAdded := retrieveContainerExecBodyPropAttachStderrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStderrAdded

	err, AttachStdinAdded := retrieveContainerExecBodyPropAttachStdinFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStdinAdded

	err, AttachStdoutAdded := retrieveContainerExecBodyPropAttachStdoutFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStdoutAdded

	err, CmdAdded := retrieveContainerExecBodyPropCmdFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || CmdAdded

	err, DetachKeysAdded := retrieveContainerExecBodyPropDetachKeysFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DetachKeysAdded

	err, EnvAdded := retrieveContainerExecBodyPropEnvFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || EnvAdded

	err, PrivilegedAdded := retrieveContainerExecBodyPropPrivilegedFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || PrivilegedAdded

	err, TtyAdded := retrieveContainerExecBodyPropTtyFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || TtyAdded

	err, UserAdded := retrieveContainerExecBodyPropUserFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || UserAdded

	err, WorkingDirAdded := retrieveContainerExecBodyPropWorkingDirFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || WorkingDirAdded

	return nil, retAdded
}

func retrieveContainerExecBodyPropAttachStderrFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagAttachStderrName := fmt.Sprintf("%v.AttachStderr", cmdPrefix)
	if cmd.Flags().Changed(flagAttachStderrName) {

		var flagAttachStderrName string
		if cmdPrefix == "" {
			flagAttachStderrName = "AttachStderr"
		} else {
			flagAttachStderrName = fmt.Sprintf("%v.AttachStderr", cmdPrefix)
		}

		flagAttachStderrValue, err := cmd.Flags().GetBool(flagAttachStderrName)
		if err != nil {
			return err, false
		}
		m.AttachStderr = flagAttachStderrValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropAttachStdinFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagAttachStdinName := fmt.Sprintf("%v.AttachStdin", cmdPrefix)
	if cmd.Flags().Changed(flagAttachStdinName) {

		var flagAttachStdinName string
		if cmdPrefix == "" {
			flagAttachStdinName = "AttachStdin"
		} else {
			flagAttachStdinName = fmt.Sprintf("%v.AttachStdin", cmdPrefix)
		}

		flagAttachStdinValue, err := cmd.Flags().GetBool(flagAttachStdinName)
		if err != nil {
			return err, false
		}
		m.AttachStdin = flagAttachStdinValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropAttachStdoutFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagAttachStdoutName := fmt.Sprintf("%v.AttachStdout", cmdPrefix)
	if cmd.Flags().Changed(flagAttachStdoutName) {

		var flagAttachStdoutName string
		if cmdPrefix == "" {
			flagAttachStdoutName = "AttachStdout"
		} else {
			flagAttachStdoutName = fmt.Sprintf("%v.AttachStdout", cmdPrefix)
		}

		flagAttachStdoutValue, err := cmd.Flags().GetBool(flagAttachStdoutName)
		if err != nil {
			return err, false
		}
		m.AttachStdout = flagAttachStdoutValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropCmdFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagCmdName := fmt.Sprintf("%v.Cmd", cmdPrefix)
	if cmd.Flags().Changed(flagCmdName) {
		// warning: Cmd array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropDetachKeysFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagDetachKeysName := fmt.Sprintf("%v.DetachKeys", cmdPrefix)
	if cmd.Flags().Changed(flagDetachKeysName) {

		var flagDetachKeysName string
		if cmdPrefix == "" {
			flagDetachKeysName = "DetachKeys"
		} else {
			flagDetachKeysName = fmt.Sprintf("%v.DetachKeys", cmdPrefix)
		}

		flagDetachKeysValue, err := cmd.Flags().GetString(flagDetachKeysName)
		if err != nil {
			return err, false
		}
		m.DetachKeys = flagDetachKeysValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropEnvFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagEnvName := fmt.Sprintf("%v.Env", cmdPrefix)
	if cmd.Flags().Changed(flagEnvName) {
		// warning: Env array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropPrivilegedFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagPrivilegedName := fmt.Sprintf("%v.Privileged", cmdPrefix)
	if cmd.Flags().Changed(flagPrivilegedName) {

		var flagPrivilegedName string
		if cmdPrefix == "" {
			flagPrivilegedName = "Privileged"
		} else {
			flagPrivilegedName = fmt.Sprintf("%v.Privileged", cmdPrefix)
		}

		flagPrivilegedValue, err := cmd.Flags().GetBool(flagPrivilegedName)
		if err != nil {
			return err, false
		}
		m.Privileged = &flagPrivilegedValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropTtyFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagTtyName := fmt.Sprintf("%v.Tty", cmdPrefix)
	if cmd.Flags().Changed(flagTtyName) {

		var flagTtyName string
		if cmdPrefix == "" {
			flagTtyName = "Tty"
		} else {
			flagTtyName = fmt.Sprintf("%v.Tty", cmdPrefix)
		}

		flagTtyValue, err := cmd.Flags().GetBool(flagTtyName)
		if err != nil {
			return err, false
		}
		m.Tty = flagTtyValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropUserFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagUserName := fmt.Sprintf("%v.User", cmdPrefix)
	if cmd.Flags().Changed(flagUserName) {

		var flagUserName string
		if cmdPrefix == "" {
			flagUserName = "User"
		} else {
			flagUserName = fmt.Sprintf("%v.User", cmdPrefix)
		}

		flagUserValue, err := cmd.Flags().GetString(flagUserName)
		if err != nil {
			return err, false
		}
		m.User = flagUserValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPropWorkingDirFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	flagWorkingDirName := fmt.Sprintf("%v.WorkingDir", cmdPrefix)
	if cmd.Flags().Changed(flagWorkingDirName) {

		var flagWorkingDirName string
		if cmdPrefix == "" {
			flagWorkingDirName = "WorkingDir"
		} else {
			flagWorkingDirName = fmt.Sprintf("%v.WorkingDir", cmdPrefix)
		}

		flagWorkingDirValue, err := cmd.Flags().GetString(flagWorkingDirName)
		if err != nil {
			return err, false
		}
		m.WorkingDir = flagWorkingDirValue

		retAdded = true
	}

	return nil, retAdded
}
